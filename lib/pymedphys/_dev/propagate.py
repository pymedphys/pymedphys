# Copyright (C) 2020 Simon Biggs
# Copyright (C) 2025 Matthew Jennings

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import io
import re
import subprocess
import textwrap
from typing import List, Optional

from pymedphys._imports import tomlkit

from .paths import DEPENDENCY_EXTRA_PATH, LIBRARY_PATH, REPO_ROOT

PYPROJECT_TOML_PATH = REPO_ROOT.joinpath("pyproject.toml")
UV_LOCK_PATH = REPO_ROOT.joinpath("uv.lock")
PYPROJECT_TOML_HASH_PATH = REPO_ROOT.joinpath("pyproject.hash")

VERSION_PATH = LIBRARY_PATH.joinpath("_version.py")

REQUIREMENTS_CONFIG = (
    # Extras | Filename | Include PyMedPhys | Make it an editable dev install
    (["user"], "requirements.txt", True, False),
    # (["all"], "requirements-all.txt", True, True),
    # (["user", "tests"], "requirements-deploy.txt", False, None),
    # (["icom"], "requirements-icom.txt", False, None),
    # (["cli"], "requirements-cli.txt", False, None),
    # (["tests"], "requirements-tests.txt", False, None),
    (["docs"], "requirements-docs.txt", True, True),
)

AUTOGEN_MESSAGE = [
    "# DO NOT EDIT THIS FILE!",
    "# This file has been autogenerated by `uv run -- pymedphys dev propagate`",
]


def propagate_all(args):
    if args.update:
        subprocess.check_call("uv lock --upgrade", shell=True)
        subprocess.check_call("uv sync --extra all --group dev", shell=True)

    propagate_version()
    propagate_extras()
    propagate_lock_requirements_and_hash()


def propagate_lock_requirements_and_hash():
    """Propagate uv.lock, requirements.txt, and pyproject.hash

    Order here is important. Lock file propagation from pyproject.toml
    is needed to create an up to date requirements. uv.lock file
    creation is non-deterministic via OS, so the hash propagation is
    undergone last to verify that this step has been run to its
    completion for the given pyproject.toml file.

    """

    _update_uv_lock()
    _propagate_requirements()
    _propagate_pyproject_hash()


def _update_uv_lock():
    subprocess.check_call("uv lock", shell=True)


def _read_text_utf8(path):
    # Robust UTF-8 read; tolerates an optional BOM if present
    try:
        with io.open(path, "r", encoding="utf-8", newline="") as f:
            return f.read()
    except UnicodeDecodeError:
        with io.open(path, "r", encoding="utf-8-sig", newline="") as f:
            return f.read()


def read_pyproject():
    text = _read_text_utf8(PYPROJECT_TOML_PATH)
    return tomlkit.loads(text)


def get_version_string():
    pyproject_contents = read_pyproject()
    version_string = pyproject_contents["project"]["version"]

    return version_string


def propagate_version():
    version_string = get_version_string()
    version_list = re.split(r"[-\.]", version_string)

    for i, item in enumerate(version_list):
        try:
            version_list[i] = int(item)
        except ValueError:
            pass

    version_contents = textwrap.dedent(
        f"""\
        {AUTOGEN_MESSAGE[0]}
        {AUTOGEN_MESSAGE[1]}

        version_info = {version_list}
        __version__ = "{version_string}"
        """
    )

    with io.open(VERSION_PATH, "w", encoding="utf-8", newline="\n") as f:
        f.write(version_contents)

    subprocess.run(["ruff", "format", str(VERSION_PATH)], check=True)


def _propagate_requirements():
    """Propagates requirement files for use without uv."""
    for extras, filename, include_pymedphys, editable in REQUIREMENTS_CONFIG:
        _make_requirements_txt(
            extras=extras,
            filename=filename,
            include_pymedphys=include_pymedphys,
            editable=editable,
        )


def _make_requirements_txt(
    extras: List[str],
    filename: str,
    include_pymedphys: bool,
    editable: Optional[bool] = None,
):
    """Create a requirements file pinned from uv.lock.

    Parameters
    ----------
    extras : List[str]
        A list of pip extras to include within the requirements file.
    filename : str
        The filename of the requirements file. Will be created in the
        repo root.
    include_pymedphys : bool
        Whether or not the requirements file should include an
        installation of the git repo.
    editable : bool
        Whether or not the pymedphys install should be 'editable'.
    """
    # TODO: eliminate or adapt to uv
    if not include_pymedphys and editable is not None:
        raise ValueError("Setting editable only works if using `include_pymedphys`")

    if include_pymedphys and editable is None:
        raise ValueError("When using `include_pymedphys` need to also set `editable`")

    # Ensure requested extras actually exist
    py = read_pyproject()
    real_extras = set(py["project"]["optional-dependencies"].keys())
    missing = [x for x in extras if x not in real_extras]
    if missing:
        raise RuntimeError(f"Unknown extras in REQUIREMENTS_CONFIG: {missing}")

    filepath = REPO_ROOT.joinpath(filename)

    uv_environment_flags = " ".join([f"--extra {item}" for item in extras])

    # TODO: Once the hashes pinning issue in poetry is fixed, remove the
    # --without-hashes. See <https://github.com/python-poetry/poetry/issues/1584>
    # for more details.
    cmd = (
        "uv export --no-hashes "
        + uv_environment_flags
        + " --format requirements-txt --output-file "
        + filename
        + " --locked"
    )
    subprocess.check_call(cmd, shell=True, cwd=REPO_ROOT)

    if include_pymedphys:
        pymedphys_install_command = f".[{','.join(extras)}]\n"
        if editable:
            pymedphys_install_command = f"-e {pymedphys_install_command}"

        with io.open(filepath, "a", encoding="utf-8", newline="\n") as f:
            f.write(pymedphys_install_command)


def propagate_extras():
    """Write extras -> base package lists to dependency-extra.txt (multiline).
    Also guarantees an 'all' entry: uses explicit 'all' extra if present,
    otherwise builds a union of all extras."""
    py = read_pyproject()
    real_extras = py["project"]["optional-dependencies"]

    name_re = re.compile(
        r"\s*([A-Za-z0-9][A-Za-z0-9._\-]*)"  # base name
        r"(?:\[[^\]]*\])?"  # optional [extras]
        r"(?:\s*(?:==|>=|<=|~=|!=|===|>|<).*)?$"  # optional version spec
    )

    def base_name(spec: str) -> str:
        head = spec.split(";", 1)[0].strip()  # drop any ; markers
        m = name_re.match(head)
        return m.group(1) if m else head

    # Build extras -> package list
    extras_map = {}
    for extra_name, req_list in real_extras.items():
        pkgs = {base_name(str(req)) for req in req_list}
        extras_map[extra_name] = sorted(pkgs, key=str.lower)

    # Ensure 'all' exists (prefer explicit; else union of all extras)
    if "all" not in extras_map:
        union_pkgs = set()
        for _, v in extras_map.items():
            union_pkgs.update(v)
        extras_map["all"] = sorted(union_pkgs, key=str.lower)

    # OPTIONAL: also expand [tool.pymedphys.extra-groups] into package lists.
    # Flip this to True if you want groups included alongside extras.
    include_groups = False
    tool = py.get("tool")
    if (
        include_groups
        and tool
        and "pymedphys" in tool
        and "extra-groups" in tool["pymedphys"]
    ):
        for group, extra_names in tool["pymedphys"]["extra-groups"].items():
            acc = set()
            for x in extra_names:
                acc.update(extras_map.get(x, []))
            extras_map[group] = sorted(acc, key=str.lower)

    # Emit as multiline TOML arrays with LF newlines
    tbl = tomlkit.table()
    for key in sorted(extras_map.keys(), key=str.lower):
        arr = tomlkit.array(extras_map[key]).multiline(True)
        tbl.add(key, arr)
    with io.open(DEPENDENCY_EXTRA_PATH, "w", encoding="utf-8", newline="\n") as f:
        f.write(tomlkit.dumps(tbl))
        if not str(tbl).endswith("\n"):
            f.write("\n")


def _propagate_pyproject_hash():
    """Store a stable hash of pyproject.toml for verification of propagation.

    Poetry used metadata.content-hash in Poetry.lock. uv.lock has no such key,
    so we compute a deterministic hash of pyproject.toml itself.
    """
    import hashlib

    with open(PYPROJECT_TOML_PATH, "rb") as f:
        data = f.read()
    # Normalize newlines and trim leading/trailing whitespace for stability
    data = data.replace(b"\r\n", b"\n").strip()
    content_hash = hashlib.sha256(data).hexdigest()

    with io.open(PYPROJECT_TOML_HASH_PATH, "w", encoding="utf-8", newline="\n") as f:
        f.write(content_hash + "\n")
